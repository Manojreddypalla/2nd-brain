### ðŸ”¹ 4. Prefix Sum / Cumulative Sum

**Pattern:** Running totals.

**Questions:**

- Find **subarray sum = K**.
- Find **equilibrium index** (left sum = right sum).
- Find **maximum subarray sum** (Kadaneâ€™s Algorithm).
- Given queries of ranges, find **sum between L and R**.
- Count subarrays with **even/odd sum**.

ðŸ’¡ _Concepts:_ Prefix sums, cumulative sums, Kadaneâ€™s.


## 1 Step-by-Step Logic - Find **subarray sum = K**. 

Letâ€™s dry run it ðŸ‘‡

`arr = [1, 2, 3, 4, 5], K = 9`

|Index|arr[i]|currSum|currSum - K|Seen Before?|Action|
|---|---|---|---|---|---|
|-1|â€”|0|â€”|â€”|store (0, -1)|
|0|1|1|-8|No|store (1, 0)|
|1|2|3|-6|No|store (3, 1)|
|2|3|6|-3|No|store (6, 2)|
|3|4|10|1|âœ… Yes (1 at index 0)|Found subarray from 1 to 3|

âœ… Subarray = `[2, 3, 4]`

---

## ðŸ§® C++ Code (Simple & Clean)

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

void findSubarraySumK(int arr[], int n, int K) {
    unordered_map<int, int> prefixIndex;  // prefix_sum â†’ index
    int currSum = 0;
    prefixIndex[0] = -1;  // for subarrays starting at index 0

    for (int i = 0; i < n; i++) {
        currSum += arr[i];

        if (prefixIndex.find(currSum - K) != prefixIndex.end()) {
            int start = prefixIndex[currSum - K] + 1;
            int end = i;

            cout << "âœ… Subarray with sum " << K << " found between indexes "
                 << start << " and " << end << ": ";

            for (int j = start; j <= end; j++)
                cout << arr[j] << " ";
            cout << endl;
            return;
        }

        if (prefixIndex.find(currSum) == prefixIndex.end())
            prefixIndex[currSum] = i;
    }

    cout << "âŒ No subarray with sum " << K << " found.\\n";
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = 5;
    int K = 9;

    findSubarraySumK(arr, n, K);
    return 0;
}

```

---

### ðŸ§¾ Output:

```
âœ… Subarray with sum 9 found between indexes 1 and 3: 2 3 4

```

---

## â±ï¸ Complexity

|Type|Complexity|
|---|---|
|Time|**O(n)** â€” one pass through array|
|Space|**O(n)** â€” for the hash map|


