# Getting Shells in the Lab — quick guide (short blog)

When you’re working through the book you’ll often want to jump straight into a container to inspect files, replay an exploit, or reproduce a post-compromise step. That’s what `docker exec` is for — a fast way to drop into a running container’s shell. But remember: these shortcuts are convenience tools for debugging and replaying steps **after** you’ve tried to compromise the machine the intended way.

---

## One-liner: drop into a container shell

Open a terminal on your Kali host and run:

```bash
# replace MACHINE-NAME with the container name (e.g. p-web-01, c-jumpbox-01)
sudo docker exec -it MACHINE-NAME bash
# if bash isn't available, try:
sudo docker exec -it MACHINE-NAME sh

```

You’ll land at a shell prompt inside the container. Type `exit` to leave.

---

## Why this is handy

- Inspect files, logs, config, and credentials directly.
- Reproduce commands you ran during exploitation.
- Test post-exploit persistence, cleanup, or privilege escalation steps.
- Debug services quickly (read logs, restart processes).

Real-life analogy: it’s like stepping into a rented room to examine what the previous occupant did — quick and useful, but not the same as breaking in yourself.

---

## Best practices (don’t abuse the shortcut)

- **Try to follow the intended exploitation path first.** Shortcuts can skip important learning steps.
- **Snapshot before using shortcuts** — if you want to experiment after you get in, save a VM snapshot first.
- **Use `docker logs` first** if you only need to read output: `docker logs -f MACHINE-NAME`.
- **Don’t modify targets permanently** unless you’re intentionally testing persistence; reset with `make teardown` or restore a snapshot afterward.

---

## Useful companion commands

- List running containers with names:

```bash
docker ps --format "{{.Names}}\\t{{.Status}}"

```

- Stream logs:

```bash
docker logs -f MACHINE-NAME

```

- Get a container’s IP:

```bash
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' MACHINE-NAME

```

- Copy files out of a container:

```bash
docker cp MACHINE-NAME:/path/in/container /host/path

```

---

## Quick troubleshooting inside the container

- Check processes: `ps aux`
- Tail service logs: `tail -f /var/log/<service>.log`
- Check network: `ip addr`, `netstat -tuln` or `ss -ln`
- Try basic connectivity: `curl http://localhost:80` or `ping -c 3 10.1.0.11` (if ping supported)

---

## Aliases for speed (add to `~/.bashrc`)

```bash
alias labshell='f(){ sudo docker exec -it "$1" bash || sudo docker exec -it "$1" sh; }; f'
# use like: labshell p-web-01

```

Reload with `source ~/.bashrc`.

---

## Final tip

`docker exec` is your replay-and-debug button — perfect for reproducing post-compromise actions, checking artifacts, or cleaning up. Use it after you’ve practiced the real exploit path, and always snapshot/back up anything you’ll want to preserve. Want a one-line script that lists all lab containers and opens a shell into the one you choose? I can drop that for you.