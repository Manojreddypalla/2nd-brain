# ğŸ” Searching & Binary Search Patterns

(aka **Pattern 3**)

Letâ€™s go step-by-step â€” from basic binary search to smart variations used in interviews.

---

## ğŸ§© **Pattern Overview**

### ğŸ¯ Concept:

Binary Search works on **sorted arrays**.

We use **divide and conquer** â€” repeatedly halve the search space.

ğŸ‘‰ Time Complexity: **O(log n)**

ğŸ‘‰ Space Complexity: **O(1)** (iterative)

---

## ğŸ§  **Core Idea**

For any target value:

- If `arr[mid] == target` â†’ found ğŸ¯
- If `arr[mid] < target` â†’ search **right half**
- If `arr[mid] > target` â†’ search **left half**

---

## ğŸ’» **1ï¸âƒ£ Basic Binary Search (Iterative)**

```cpp
#include <iostream>
using namespace std;

int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == target)
            return mid; // found
        else if (arr[mid] < target)
            low = mid + 1; // search right
        else
            high = mid - 1; // search left
    }

    return -1; // not found
}

int main() {
    int arr[] = {2, 4, 6, 8, 10, 12};
    int n = 6, target = 8;
    int index = binarySearch(arr, n, target);

    if (index != -1)
        cout << "Element found at index " << index;
    else
        cout << "Not found";
}

```

âœ… Output:

```
Element found at index 3

```

---

## ğŸ’» **2ï¸âƒ£ Binary Search (Recursive)**

```cpp
int binarySearchRec(int arr[], int low, int high, int target) {
    if (low > high) return -1;

    int mid = low + (high - low) / 2;

    if (arr[mid] == target) return mid;
    else if (arr[mid] > target) return binarySearchRec(arr, low, mid - 1, target);
    else return binarySearchRec(arr, mid + 1, high, target);
}

```

ğŸ’¡ Same logic as iterative, but with recursion.

---

## ğŸ’¡ Binary Search Variations

Now, let's look at *interview-level variations* built on this pattern ğŸ‘‡

---

## ğŸ”¹ **3ï¸âƒ£ Find First and Last Occurrence**

### ğŸ§  Problem:

Find **first** and **last** position of an element (if duplicates exist).

**Example:**

```
arr = [1, 2, 2, 2, 3, 4], target = 2
Output: first = 1, last = 3

```

### ğŸ’» Code:

```cpp
#include <iostream>
using namespace std;

int firstOcc(int arr[], int n, int target) {
    int low = 0, high = n - 1, res = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            res = mid;
            high = mid - 1; // keep checking left
        } else if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return res;
}

int lastOcc(int arr[], int n, int target) {
    int low = 0, high = n - 1, res = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            res = mid;
            low = mid + 1; // keep checking right
        } else if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return res;
}

int main() {
    int arr[] = {1, 2, 2, 2, 3, 4};
    int n = 6, target = 2;
    cout << "First: " << firstOcc(arr, n, target) << endl;
    cout << "Last: " << lastOcc(arr, n, target);
}

```

âœ… Output:

```
First: 1
Last: 3

```

---

## ğŸ”¹ **4ï¸âƒ£ Count Number of Occurrences**

Once you know **first** and **last index**,

you can easily calculate:

```cpp
count = lastIndex - firstIndex + 1;

```

**Example:**

```
First = 1, Last = 3 â†’ Count = 3

```

---

## ğŸ”¹ **5ï¸âƒ£ Find the Index Where Element Should Be Inserted**

**Problem:**

If the element isnâ€™t found, return the **index where it should be inserted**

to maintain sorted order.

**Example:**

```
arr = [1, 3, 5, 6]
target = 2 â†’ Output = 1
target = 7 â†’ Output = 4

```

### ğŸ’» Code:

```cpp
int searchInsert(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target)
            return mid;
        else if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return low; // position to insert
}

```

âœ… Works just like binary search â€” but if not found, `low` ends up at insertion point.

---

## ğŸ”¹ **6ï¸âƒ£ Find Peak Element (Mountain Array)**

**Problem:**

A peak element is greater than its neighbors.

Find any one peak.

**Example:**

```
arr = [1, 3, 20, 4, 1, 0]
Output: 20 (index 2)

```

### ğŸ’» Code:

```cpp
int findPeak(int arr[], int n) {
    int low = 0, high = n - 1;

    while (low < high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] < arr[mid + 1])
            low = mid + 1;  // move right
        else
            high = mid;     // move left
    }
    return low; // or high, both same at end
}

```

âœ… Output: `arr[2] = 20`

ğŸ’¡ This is **binary search on answer** â€” a common trick in advanced problems.

---

## ğŸ§© Summary Table

| Problem | Key Idea | Complexity |
| --- | --- | --- |
| Binary Search | Divide array in half | O(log n) |
| First/Last Occurrence | Move mid left/right on equal | O(log n) |
| Count Occurrences | last - first + 1 | O(log n) |
| Insert Position | Return `low` when not found | O(log n) |
| Peak Element | Compare mid & mid+1 | O(log n) |

---

Would you like me to prepare **5 practice questions (with hints)** for this pattern next â€” so you can test yourself before moving to the **Prefix Sum / Sliding Window pattern** tomorrow?


ğŸ§© 1ï¸âƒ£ Basic Binary Search
ğŸ§  What it does:

Quickly finds an element in a sorted dataset â€” O(log n) time.

ğŸ’¼ Where used in real life:

âœ… Search features

When you type a name in a contact list (sorted alphabetically), binary search helps locate the match quickly.

Used in auto-suggestion, search bars, and file systems.

âœ… Backend querying

In e-commerce or news sites, products or articles are sorted (by price, date, etc.).

Binary search helps find where a certain price/date falls.

âœ… Games / AI

Used for pathfinding, level lookup, or finding thresholds in sorted scores.

ğŸ§© 2ï¸âƒ£ First / Last Occurrence
ğŸ§  What it does:

Finds the start and end positions of a repeated element.

ğŸ’¼ Where used:

âœ… Search Engines / Text Processing

To find the range of matching keywords in sorted indexes.

âœ… Database Indexing

Databases keep sorted indexes for quick searching.
If you search for â€œusername = Manojâ€,
binary search finds the first and last record for â€œManojâ€.

âœ… Analytics / Logs

Finding when an event starts and ends (like user logins in a sorted timestamp list).

ğŸ§© 3ï¸âƒ£ Count Occurrences
ğŸ’¼ Where used:

âœ… Data Analytics

Counting how many times a product was sold, user logged in, or page was visited.

âœ… Search Engines

Count how many documents contain a specific keyword.

âœ… Game Development

Counting how many times a player achieved a particular score (stored sorted).

ğŸ§© 4ï¸âƒ£ Search Insert Position
ğŸ§  What it does:

Tells where to insert an element to keep a list sorted.

ğŸ’¼ Where used:

âœ… Ranking systems

When inserting a new player score into a leaderboard (scores sorted high to low).

âœ… Financial / Stock Apps

Inserting a new stock price in sorted order to maintain efficient access.

âœ… Databases

When inserting a new record into a sorted index (e.g., binary trees, B-trees use this logic internally).

âœ… E-commerce

Adding a product in a sorted list of items by price or rating.

ğŸ§© 5ï¸âƒ£ Find Peak Element
ğŸ§  What it does:

Finds a local maximum â€” where value is higher than neighbors.

ğŸ’¼ Where used:

âœ… Signal Processing / Sensor Data

Find peaks in temperature, sound waves, or performance charts.

âœ… Finance / Stocks

Detecting peaks and dips in stock prices over time.

âœ… AI / Machine Learning

In optimization problems, finding local maxima/minima in loss functions (used in gradient algorithms).

âœ… Gaming / Simulations

Finding best moment (peak performance or resource usage).

ğŸ§  So in projectsâ€¦

Youâ€™ll often see Binary Search used inside:

Search & recommendation systems

Analytics dashboards

Real-time sensor processing

Sorted data management (e.g., leaderboards, logs, product prices)

ğŸ§© Practical Example: Search Feature

Letâ€™s say youâ€™re building a Book Search Web App ğŸ“š

Backend flow:

Store all books sorted by name.

When user types "Harry Potter",

Use binary search to find where "Harry" would start in that sorted list.

Then keep going forward (linear) until names donâ€™t match "Harry" anymore.

âœ… Fast search even with millions of books.

ğŸ§© Example: Stock Market Project

Youâ€™re tracking daily prices:

arr = [100, 102, 105, 103, 108, 110]


Use peak element search to find the local top price.

Use insert position search to quickly insert a new dayâ€™s price into a sorted list.

ğŸ§© Example: Leaderboard System
scores = [950, 900, 860, 820, 790]


When a new player gets 870 points:

Use binary search insert position â†’ index 2

Insert at that position â†’ maintain sorted order instantly.

âš¡ TL;DR â€” Where to use Binary Search in projects:
Pattern	Real Project Use
Basic Binary Search	Search in sorted data (contacts, lists, database records)
First/Last Occurrence	Log analysis, range queries
Count Occurrences	Analytics, tracking activity frequency
Insert Position	Leaderboards, sorted inserts, stock prices
Peak Element	Signal/stock analysis, optimization problems

Would you like me to show how to use binary search inside a small project (like a leaderboard system in C++ or Python)?
Thatâ€™ll show you exactly how to connect theory â†’ project code.