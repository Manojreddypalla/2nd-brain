### ðŸŽ¯ **Goal:**

Learn to **organize elements** in ascending, descending, or specific logical orders using loops, swaps, or conditions.

---

## ðŸ§  **Concepts Covered**

- Basic sorting algorithms
- Rearranging elements (like 0s, 1s, negatives)
- Two-pointer logic
- Partition-based rearrangements

---

## ðŸ’» Example Problems (with C++ Templates)

---

### âœ… 1. Bubble Sort (Basic Sorting)

**Question:** Sort array elements in ascending order using Bubble Sort.

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int arr[n];
    for (int i = 0; i < n; i++) cin >> arr[i];

    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
}

```

ðŸ’¡ _Concept:_ Swap adjacent elements until the array is sorted.

ðŸ§© _Time Complexity:_ O(nÂ²)

---

### âœ… 2. Selection Sort

**Question:** Sort the array using the selection sort technique.

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int arr[n];
    for (int i = 0; i < n; i++) cin >> arr[i];

    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex])
                minIndex = j;
        }
        swap(arr[i], arr[minIndex]);
    }

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
}

```

ðŸ’¡ _Concept:_ Find the smallest element and place it in the correct position.

ðŸ§© _Time Complexity:_ O(nÂ²)

## 3. ðŸ§© **Problem Statement**

Youâ€™re given an array of integers (positive, negative, or zero).

You need to **rearrange** it so that all **negative numbers appear before positive numbers**,

but the **order among them doesnâ€™t matter**.

---

### ðŸ§  Example:

**Input:**

```
arr = [1, -2, 3, -4, -1, 5]

```

**Output:**

```
[-2, -4, -1, 1, 3, 5]

```

âœ… All negative numbers are on the left side

âœ… All positive numbers are on the right side

---

## âš™ï¸ **Logic**

We can solve this using the **two-pointer technique** (like QuickSort partitioning).

### Idea:

- Keep a pointer `j` for the position where the next negative number should go.
- Traverse the array from start to end.
- Whenever you find a **negative number**, swap it with the element at index `j` and then increment `j`.

---

### ðŸ”¢ Step-by-Step Dry Run

**arr = [1, -2, 3, -4, -1, 5]**

|i|arr[i]|j|Action|Array after action|
|---|---|---|---|---|
|0|1|0|1 is +ve â†’ do nothing|[1, -2, 3, -4, -1, 5]|
|1|-2|0|-2 is -ve â†’ swap arr[i] & arr[j], j++|[-2, 1, 3, -4, -1, 5]|
|2|3|1|3 is +ve â†’ do nothing|[-2, 1, 3, -4, -1, 5]|
|3|-4|1|swap arr[i] & arr[j], j++|[-2, -4, 3, 1, -1, 5]|
|4|-1|2|swap arr[i] & arr[j], j++|[-2, -4, -1, 1, 3, 5]|
|5|5|3|+ve â†’ do nothing|[-2, -4, -1, 1, 3, 5]|

âœ… Final array: `[-2, -4, -1, 1, 3, 5]`

---

## ðŸ’» **Code (C++)**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int arr[n];
    for (int i = 0; i < n; i++) cin >> arr[i];

    int j = 0; // index for negative numbers
    for (int i = 0; i < n; i++) {
        if (arr[i] < 0) {
            swap(arr[i], arr[j]);
            j++;
        }
    }

    cout << "Rearranged array: ";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
}

```

---

## â±ï¸ **Time & Space Complexity**

- **Time Complexity:** O(n) â†’ single traversal
- **Space Complexity:** O(1) â†’ done in-place (no extra array)

---

## ðŸ§© **Key Takeaways**

- This pattern is the **basis for QuickSortâ€™s partition step**.
- You can modify it for other rearrangement problems like:
    - Move **zeros to one side**
    - Move **even numbers before odd numbers**
    - Group **positive and negative** alternatively

---

Would you like me to show how to **modify this same logic** to â€œmove all zeros to the endâ€? (itâ€™s a super common interview variation).

### âœ… 4. Sort Array of 0s, 1s, and 2s

**Question:** Sort without using a sorting algorithm (Dutch National Flag problem).

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int arr[n];
    for (int i = 0; i < n; i++) cin >> arr[i];

    int low = 0, mid = 0, high = n - 1;

    while (mid <= high) {
        if (arr[mid] == 0) {
            swap(arr[low++], arr[mid++]);
        } else if (arr[mid] == 1) {
            mid++;
        } else {
            swap(arr[mid], arr[high--]);
        }
    }

    cout << "Sorted 0s,1s,2s: ";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
}

```

ðŸ’¡ _Concept:_ Three-way partition â€” single-pass O(n).

ðŸ§© _Use Case:_ Colors, binary states, or category grouping.

## ðŸ§  Intuition:

We keep checking elements at index `mid` and place them in the correct region:

- If `arr[mid] == 0`: it belongs to the _left side_.
    
    â†’ Swap with `low`, move both `low` and `mid` forward.
    
- If `arr[mid] == 1`: itâ€™s already in the correct _middle_ section.
    
    â†’ Just move `mid` forward.
    
- If `arr[mid] == 2`: it belongs to the _right side_.
    
    â†’ Swap with `high` and move `high` backward (but not `mid`).
    

---

### âœ… 5. Rearrange Array in Alternate Positive and Negative Order

**Question:** Arrange + and â€“ numbers alternatively (extra space allowed).

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> arr(n), pos, neg;

    for (int i = 0; i < n; i++) cin >> arr[i];

    for (int x : arr) {
        if (x >= 0) pos.push_back(x);
        else neg.push_back(x);
    }

    int i = 0, p = 0, q = 0;
    while (p < pos.size() && q < neg.size()) {
        arr[i++] = pos[p++];
        arr[i++] = neg[q++];
    }
    while (p < pos.size()) arr[i++] = pos[p++];
    while (q < neg.size()) arr[i++] = neg[q++];

    cout << "Rearranged alternately: ";
    for (int x : arr) cout << x << " ";
}

```

ðŸ’¡ _Concept:_ Two lists merged alternatively.

ðŸ§© _Time Complexity:_ O(n)

## ðŸ’¡ **Key Notes**

- This approach is **simple** and **clear**, but uses **extra space**.
- You can make it **in-place** (without extra arrays) using **rotation logic** â€” more complex but space-efficient.

---

### âš¡ Real-Life Analogy:

Think of a teacher arranging students:

> one boy (positive), one girl (negative), one boy, one girlâ€¦
> 
> If one group runs out, others line up at the end.

---

### ðŸš€ **Mini Practice Challenges**

Try writing these yourself:

1. Sort the array in **descending order** (modify bubble sort).
2. Move all **zeros to the end**.
3. Sort array by **absolute values**.
4. Arrange **even numbers first, odd numbers after**.
5. Find **kth smallest/largest** element (use sorting).